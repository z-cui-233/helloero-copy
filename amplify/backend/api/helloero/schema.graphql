type UserWabikenMeta @model @auth(rules: [{ allow: owner }]) {
  """
  same as token
  """
  id: ID!
  token: String!
  version: Int!
  not_valid_before: AWSTimestamp!
  not_valid_after: AWSTimestamp!
  lock_required: Boolean!
  playback_remain: Int!
  validity_period: Int!
  issuer_trace: String
  created_at: AWSTimestamp!
  content: ContentMeta!
  """
  following are required fields in UserWabikenMeta (as they are activated wabikens)
  """
  activated_at: AWSTimestamp!
  locked_to: String!
}

type WabikenMeta {
  id: ID!
  """
  token
  """
  token: String!
  version: Int!
  not_valid_before: AWSTimestamp!
  not_valid_after: AWSTimestamp!
  lock_required: Boolean!
  playback_remain: Int!
  validity_period: Int!
  created_at: AWSTimestamp!
  content: ContentMeta!
  issuer_trace: String
  locked_to: String # This will be null for non-activated wabiken
  activated_at: AWSTimestamp # This will be null for non-activated wabiken
}

type CodeName {
  code: String!
  name: String!
}

type Period {
  since: AWSTimestamp
  until: AWSTimestamp
}

type ContentMetaKey {
  id: ID!
  type: String!
  provider_id: String!
}

type ContentMetaThumbnail {
  package_l: String
  package_m: String
  package_s: String
  standard: String
  tspt_fhds: String
  tspt_fwxga: String
}

type ContentMeta {
  id: ID!
  key: ContentMetaKey!
  catchphrase: String!
  comment: String!
  duration: Int!
  evaluation_point: Int
  maker: CodeName!
  series: CodeName!
  release_date: String!
  public_period: Period!
  sale_period: Period!
  payment_badge: CodeName!
  thumbnails: ContentMetaThumbnail!
  main_episode_code: String!
}
type ErrorCodeMessage {
  code: Int!
  message: String!
}
type WabikenMetaResponse {
  wabiken: WabikenMeta!
  result: Boolean!
}

type SceneSearchSize {
  width: Int!
  height: Int!
}

type SceneSearch {
  scene_search_url: AWSURL!
  extra: SceneSearchSize!
}

type SceneSearchList {
  IMS_AD1: [SceneSearch!]
  IMS_L: [SceneSearch!]
  IMS_M: [SceneSearch!]
  IMS_S: [SceneSearch!]
}

type ISemMeta {
  version: String!
  endpoint: AWSURL!
  isemToken: String!
}

type PlayInfoEndpointExtra {
  play_token: String!
  play_token_hash: String!
}

type PlayInfoEndpoint {
  id: ID!
  display_name: String!
  scene_search_list: SceneSearchList
  playables: [Playable!]!
  isem: ISemMeta!
  extra: PlayInfoEndpointExtra!
}

type LicenseUrl {
  drmType: String!
  version: String!
  endpoint: AWSURL!
}
type PlayableCdn {
  cdn_id: String!
  weight: Int!
  playlist_url: AWSURL!
  license_url_list: [LicenseUrl!]!
}
type Playable {
  type: String!
  cdns: [PlayableCdn!]!
}

type PlayInfo {
  type: String!
  landing_page: String!
  endpoints: [PlayInfoEndpoint!]!
  refresh_token: String!
  playback_remain: Int!
  not_valid_before: AWSTimestamp!
  not_valid_after: AWSTimestamp!
}

type PlayInfoResponse {
  playinfo: PlayInfo!
  result: Boolean!
}

type Query {
  getWabikenMeta(id: ID!): WabikenMetaResponse
    @function(name: "helloeroLambdaResolver")
  getPlayInfo(
    token: String!
    deviceCode: String!
    lock: String!
    deviceId: String!
  ): PlayInfoResponse @function(name: "helloeroLambdaResolver")
}

type Mutation {
  activateWabiken(token: String!, lockTo: String!): WabikenMetaResponse
    @function(name: "helloeroLambdaResolver")
}
