type UserWabikenMeta @model @auth(rules: [{ allow: owner }]) {
  """
  same as token
  """
  id: ID!
  version: Int!
  notValidBefore: AWSTimestamp!
  notValidAfter: AWSTimestamp!
  lockRequired: Boolean!
  playbackRemain: Int!
  validityPeriod: Int!
  issuerTrace: String
  createdAt: AWSTimestamp!
  content: ContentMeta!
  """
  following are required fields in UserWabikenMeta (as they are activated wabikens)
  """
  activatedAt: AWSTimestamp!
  lockedTo: String!
}

type WabikenMeta {
  id: ID!
  """
  token
  """
  version: Int!
  notValidBefore: AWSTimestamp!
  notValidAfter: AWSTimestamp!
  lockRequired: Boolean!
  playbackRemaining: Int!
  validityPeriod: Int!
  createdAt: AWSTimestamp!
  content: ContentMeta!
  issuerTrace: String
  lockedTo: String # This will be null for non-activated wabiken
  activatedAt: AWSTimestamp # This will be null for non-activated wabiken
}

type CodeName {
  code: String!
  name: String!
}

type Period {
  since: AWSTimestamp
  until: AWSTimestamp
}

type ContentMetaKey {
  id: ID!
  type: String!
  providerId: String!
}

type ContentMetaThumbnail {
  packageL: String
  packageM: String
  packageS: String
  standard: String
  tsptFhds: String
  tsptFwxga: String
}

type ContentMeta {
  id: ID!
  key: ContentMetaKey!
  catchphrase: String!
  comment: String!
  duration: Int!
  evaluationPoint: Int
  maker: CodeName!
  series: CodeName!
  releaseDate: String!
  publicPeriod: Period!
  salePeriod: Period!
  paymentBadge: CodeName!
  thumbnails: ContentMetaThumbnail # verify: content meta except key is not being returned by activated wabiken put request
  mainEpisodeCode: String!
}
type ErrorCodeMessage {
  code: Int!
  message: String!
}
type WabikenMetaResponse {
  wabiken: WabikenMeta!
  result: Boolean!
}

type SceneSearchSize {
  width: Int!
  height: Int!
}

type SceneSearchCdn {
  sceneSearchUrl: AWSURL!
  extra: SceneSearchSize!
}

type SceneSearch {
  type: String!
  cdns: [SceneSearchCdn!]!
}

type ISemMeta {
  version: String!
  endpoint: AWSURL!
  isemToken: String!
}

type PlayInfoEndpointExtra {
  playToken: String!
  playTokenHash: String!
}

type PlayInfoEndpoint {
  id: ID!
  displayName: String!
  sceneSearchList: [SceneSearch!]!
  playables: [Playable!]!
  isem: ISemMeta!
  extra: PlayInfoEndpointExtra!
}

type LicenseUrl {
  drmType: String!
  version: String!
  endpoint: AWSURL!
}
type PlayableCdn {
  cdnId: String
  weight: Int!
  playlistUrl: AWSURL!
  licenseUrlList: [LicenseUrl!]!
}
type Playable {
  type: String!
  cdns: [PlayableCdn!]!
}

type PlayInfo {
  type: String!
  landingPage: String!
  endpoints: [PlayInfoEndpoint!]!
  refreshToken: String!
  playbackRemaining: Int!
  notValidBefore: AWSTimestamp!
  notValidAfter: AWSTimestamp!
}

type PlayInfoResponse {
  playInfo: PlayInfo!
  result: Boolean!
}

type Query {
  getWabikenMeta(id: ID!): WabikenMetaResponse
    @function(name: "helloeroLambdaResolver")
  getPlayInfo(
    token: String!
    deviceCode: String!
    lock: String!
    deviceId: String!
  ): PlayInfoResponse @function(name: "helloeroLambdaResolver")
}

type Mutation {
  activateWabiken(token: String!, lockTo: String!): WabikenMetaResponse
    @function(name: "helloeroLambdaResolver")
}
