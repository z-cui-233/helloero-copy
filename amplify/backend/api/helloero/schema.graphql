type UserWabikenMeta
  @model
  @auth(rules: [{ allow: owner, operations: [create, update, read] }]) {
  """
  same as token
  """
  id: ID!
  token: String!
  version: Int!
  not_valid_before: AWSTimestamp!
  not_valid_after: AWSTimestamp!
  lock_required: Boolean!
  playback_remain: Int!
  validity_period: Int!
  issuer_tracer: String
  created_at: AWSTimestamp!
  activated_at: AWSTimestamp!
  content: ContentMeta!
  """
  required field in UserWabikenMeta, compared to optional in WabikenMeta
  """
  locked_to: String!
}

type WabikenMeta {
  id: ID!
  """
  token
  """
  token: String!
  version: Int!
  not_valid_before: AWSTimestamp!
  not_valid_after: AWSTimestamp!
  lock_required: Boolean!
  playback_remain: Int!
  validity_period: Int!
  issuer_tracer: String
  created_at: AWSTimestamp!
  activated_at: AWSTimestamp!
  locked_to: String
  content: ContentMeta!
}

type CodeName {
  code: String!
  name: String!
}

type Period {
  since: AWSTimestamp
  until: AWSTimestamp
}

type ContentMetaKey {
  id: ID!
  type: String!
  provider_id: String!
}

type Thumbnail { # TBD
  url: AWSURL!
}

type ContentMeta {
  id: ID!
  key: ContentMetaKey!
  catchphrase: String!
  comment: String!
  duration: Int!
  evaluation_point: Int
  maker: CodeName!
  series: CodeName!
  release_date: String!
  public_period: Period!
  sale_period: Period!
  payment_badge: CodeName!
  thumbnails: [Thumbnail!]
  main_episode_code: String!
}
type ErrorCodeMessage {
  code: Int!
  message: String!
}
type WabikenMetaResponse {
  wabiken: WabikenMeta!
  result: Boolean!
}

type SceneSearchSize {
  width: Int!
  height: Int!
}

type SceneSearch {
  scene_search_url: AWSURL!
  extra: SceneSearchSize!
}

type SceneSearchList {
  IMS_AD1: [SceneSearch!]!
  IMS_L: [SceneSearch!]!
  IMS_M: [SceneSearch!]!
  IMS_S: [SceneSearch!]!
}

type PlayInfoEndpoint {
  id: ID!
  display_name: String!
  scene_search_list: SceneSearchList
}

type LicenseUrl {
  version: String!
  endpoint: AWSURL!
}

type LicenseUrlList {
  playready: LicenseUrl
  widevine: LicenseUrl
}

type Playable {
  weight: Int!
  cdn_idn: String!
  playlist_url: AWSURL!
  license_url_list: LicenseUrlList
}

type PlayableList {
  dash: [Playable!]!
  smooth: [Playable!]!
}

type PlayInfo { # TBD
  type: String!
  landing_page: String!
  endpoints: [PlayInfoEndpoint!]!
  playables: PlayableList!
  isem_token: String!
  refresh_token: String!
  playback_remain: Int!
  not_valid_before: AWSTimestamp!
  not_valid_after: AWSTimestamp!
}

type PlayInfoResponse {
  playinfo: PlayInfo!
  result: Boolean!
}

type Query {
  getWabikenMeta(id: ID!): WabikenMetaResponse
    @function(name: "helloeroLambdaResolver")
  getPlayinfo(
    token: String!
    deviceCode: String!
    lock: String!
    deviceId: String!
  ): PlayInfoResponse @function(name: "helloeroLambdaResolver")
}

type Mutation {
  activateWabiken(token: String!, lockTo: String!): WabikenMetaResponse
    @function(name: "helloeroLambdaResolver")
}
